<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Brick Breaker</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;700&family=Titan+One&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', 'Arial', sans-serif;
            background: linear-gradient(135deg, #020617 0%, #0f172a 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            color: #22d3ee;
        }

        #gameContainer {
            position: relative;
            width: 600px;
            height: 800px;
            background: linear-gradient(135deg, #020617 0%, #0f172a 100%);
            border: 3px solid #22d3ee;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(34, 211, 238, 0.3), inset 0 0 40px rgba(34, 211, 238, 0.1);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: linear-gradient(135deg, rgba(2, 6, 23, 0.95) 0%, rgba(15, 23, 42, 0.95) 100%);
            z-index: 10;
            transition: opacity 0.3s;
            border-radius: 12px;
        }

        .screen.hidden {
            display: none;
        }

        h1 {
            font-size: 3.5em;
            font-family: 'Titan One', cursive;
            background: linear-gradient(135deg, #22d3ee 0%, #f472b6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite;
            text-align: center;
            width: 100%;
            letter-spacing: 1px;
        }

        @keyframes glow {
            0%, 100% { filter: drop-shadow(0 0 10px #22d3ee); }
            50% { filter: drop-shadow(0 0 20px #f472b6); }
        }

        button {
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.2) 0%, rgba(244, 114, 182, 0.2) 100%);
            color: #22d3ee;
            border: 2px solid #22d3ee;
            padding: 15px 40px;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 30px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(34, 211, 238, 0.3);
            transition: all 0.3s;
            font-family: 'Rajdhani', inherit;
            margin: 10px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 30px rgba(244, 114, 182, 0.6);
            border-color: #f472b6;
            color: #f472b6;
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .score-display {
            font-size: 2em;
            color: #22d3ee;
            margin: 20px;
            font-weight: bold;
        }

        .high-score {
            font-size: 1.2em;
            color: #f472b6;
            margin-top: 10px;
        }

        #scoreHUD {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5em;
            color: #22d3ee;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
            z-index: 5;
        }

        #livesHUD {
            position: absolute;
            top: 60px;
            left: 20px;
            font-size: 1.2em;
            color: #f472b6;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(244, 114, 182, 0.5);
            z-index: 5;
        }

        #levelHUD {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.2em;
            color: #22d3ee;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(34, 211, 238, 0.5);
            z-index: 5;
        }

        .instructions {
            font-size: 0.9em;
            color: #cbd5e1;
            text-align: center;
            margin-top: 20px;
            padding: 0 30px;
            line-height: 1.6;
        }

        .gamepad-status {
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-size: 0.8em;
            color: #cbd5e1;
            background: rgba(34, 211, 238, 0.1);
            padding: 5px 10px;
            border-radius: 10px;
            z-index: 5;
            border: 1px solid #22d3ee;
        }

        .gamepad-status.connected {
            color: #22d3ee;
            font-weight: bold;
            box-shadow: 0 0 10px rgba(34, 211, 238, 0.3);
        }

        .pause-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3em;
            color: #f472b6;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(244, 114, 182, 0.8);
            z-index: 8;
            display: none;
            font-family: 'Titan One', cursive;
        }

        .pause-overlay.active {
            display: block;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="scoreHUD">Score: 0</div>
        <div id="livesHUD">‚ù§Ô∏è x 3</div>
        <div id="levelHUD">Level 1</div>
        <div class="gamepad-status" id="gamepadStatus">Gamepad: Desconectado</div>
        <div class="pause-overlay" id="pauseOverlay">PAUSA</div>

        <div class="screen" id="startScreen">
            <h1>CYBER BREAKER</h1>
            <div class="score-display">Rompe todos los bloques</div>
            <button id="startBtn">INICIAR</button>
            <div class="instructions">
                üéÆ <strong>Controles Gamepad:</strong><br>
                Joystick Izquierdo / D-Pad: Mover paleta<br>
                Bot√≥n A: Lanzar bola / Reintentar<br>
                Bot√≥n START: Pausar juego<br>
                <br>
                üñ±Ô∏è <strong>Controles Mouse/Teclado:</strong><br>
                Mouse: Mover paleta | Click: Lanzar<br>
                Flechas ‚Üê‚Üí: Mover | Espacio: Pausar
            </div>
        </div>

        <div class="screen hidden" id="gameOverScreen">
            <h1>GAME OVER</h1>
            <div class="score-display" id="finalScore">Score: 0</div>
            <div class="high-score" id="highScoreDisplay">High Score: 0</div>
            <button id="restartBtn">REINTENTAR</button>
        </div>

        <div class="screen hidden" id="levelCompleteScreen">
            <h1>¬°NIVEL COMPLETO!</h1>
            <div class="score-display" id="levelScore">Score: 0</div>
            <button id="nextLevelBtn">SIGUIENTE NIVEL</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 600;
        canvas.height = 800;

        // Gamepad state
        let gamepad = null;
        let gamepadIndex = null;

        // Game state
        let gameState = 'start'; // start, playing, paused, gameover, levelcomplete
        let score = 0;
        let lives = 3;
        let level = 1;
        let highScore = localStorage.getItem('brickBreakerHighScore') || 0;

        // Paddle
        const paddle = {
            x: canvas.width / 2 - 60,
            y: canvas.height - 40,
            width: 120,
            height: 15,
            speed: 8,
            dx: 0
        };

        // Ball
        const ball = {
            x: canvas.width / 2,
            y: paddle.y - 10,
            radius: 8,
            speed: 5,
            dx: 0,
            dy: 0,
            launched: false
        };

        // Bricks
        let bricks = [];
        const brickConfig = {
            rows: 5,
            cols: 8,
            width: 65,
            height: 25,
            padding: 5,
            offsetX: 20,
            offsetY: 80
        };

        const brickColors = [
            { color: '#22d3ee', glow: 'rgba(34, 211, 238, 0.5)', points: 10 },
            { color: '#f472b6', glow: 'rgba(244, 114, 182, 0.5)', points: 20 },
            { color: '#a78bfa', glow: 'rgba(167, 139, 250, 0.5)', points: 30 },
            { color: '#fbbf24', glow: 'rgba(251, 191, 36, 0.5)', points: 40 },
            { color: '#f87171', glow: 'rgba(248, 113, 113, 0.5)', points: 50 }
        ];

        // Particles for effects
        let particles = [];

        // Initialize bricks
        function createBricks() {
            bricks = [];
            for (let row = 0; row < brickConfig.rows + level - 1; row++) {
                for (let col = 0; col < brickConfig.cols; col++) {
                    const colorIndex = Math.min(row, brickColors.length - 1);
                    bricks.push({
                        x: col * (brickConfig.width + brickConfig.padding) + brickConfig.offsetX,
                        y: row * (brickConfig.height + brickConfig.padding) + brickConfig.offsetY,
                        width: brickConfig.width,
                        height: brickConfig.height,
                        active: true,
                        ...brickColors[colorIndex]
                    });
                }
            }
        }

        // Gamepad detection
        window.addEventListener('gamepadconnected', (e) => {
            gamepad = e.gamepad;
            gamepadIndex = e.gamepad.index;
            updateGamepadStatus(true);
        });

        window.addEventListener('gamepaddisconnected', () => {
            gamepad = null;
            gamepadIndex = null;
            updateGamepadStatus(false);
        });

        function updateGamepadStatus(connected) {
            const status = document.getElementById('gamepadStatus');
            status.textContent = connected ? 'üéÆ Gamepad Conectado' : 'Gamepad: Desconectado';
            status.className = connected ? 'gamepad-status connected' : 'gamepad-status';
        }

        function pollGamepad() {
            if (gamepadIndex !== null) {
                const gamepads = navigator.getGamepads();
                gamepad = gamepads[gamepadIndex];
                
                if (gamepad && gameState === 'playing') {
                    // Joystick izquierdo (axes[0]) o D-pad
                    const axisX = gamepad.axes[0];
                    const deadzone = 0.2;
                    
                    if (Math.abs(axisX) > deadzone) {
                        paddle.dx = axisX * paddle.speed;
                    } else {
                        paddle.dx = 0;
                    }

                    // Bot√≥n A (√≠ndice 0) para lanzar bola
                    if (gamepad.buttons[0].pressed && !ball.launched) {
                        launchBall();
                    }

                    // Bot√≥n START (√≠ndice 9) para pausar
                    if (gamepad.buttons[9].pressed && !gamepad.buttons[9].wasPressed) {
                        togglePause();
                    }
                    gamepad.buttons[9].wasPressed = gamepad.buttons[9].pressed;
                }

                // En pantalla de game over, bot√≥n A para reiniciar
                if (gameState === 'gameover' && gamepad.buttons[0].pressed) {
                    resetGame();
                }
            }
        }

        // Mouse controls
        canvas.addEventListener('mousemove', (e) => {
            if (gameState === 'playing') {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                paddle.x = mouseX - paddle.width / 2;
                
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) {
                    paddle.x = canvas.width - paddle.width;
                }
            }
        });

        canvas.addEventListener('click', () => {
            if (gameState === 'playing' && !ball.launched) {
                launchBall();
            }
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (gameState === 'playing') {
                if (e.key === 'ArrowLeft') paddle.dx = -paddle.speed;
                if (e.key === 'ArrowRight') paddle.dx = paddle.speed;
                if (e.key === ' ' && !ball.launched) {
                    e.preventDefault();
                    launchBall();
                }
                if (e.key === 'Escape' || e.key === ' ') {
                    togglePause();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                paddle.dx = 0;
            }
        });

        function launchBall() {
            if (!ball.launched) {
                ball.launched = true;
                const angle = (Math.random() - 0.5) * Math.PI / 3;
                ball.dx = ball.speed * Math.sin(angle);
                ball.dy = -ball.speed * Math.cos(angle);
            }
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                document.getElementById('pauseOverlay').classList.add('active');
            } else if (gameState === 'paused') {
                gameState = 'playing';
                document.getElementById('pauseOverlay').classList.remove('active');
            }
        }

        // Particle system
        function createParticles(x, y, color) {
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 4,
                    vy: (Math.random() - 0.5) * 4,
                    life: 1,
                    color: color
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        // Draw functions
        function drawPaddle() {
            ctx.save();
            ctx.shadowColor = '#22d3ee';
            ctx.shadowBlur = 15;
            
            const gradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
            gradient.addColorStop(0, '#22d3ee');
            gradient.addColorStop(1, '#0891b2');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            
            ctx.strokeStyle = '#22d3ee';
            ctx.lineWidth = 2;
            ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.restore();
        }

        function drawBall() {
            ctx.save();
            ctx.shadowColor = '#f472b6';
            ctx.shadowBlur = 20;
            
            const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ball.radius);
            gradient.addColorStop(0, '#ffffff');
            gradient.addColorStop(0.3, '#f472b6');
            gradient.addColorStop(1, '#ec4899');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawBricks() {
            bricks.forEach(brick => {
                if (brick.active) {
                    ctx.save();
                    ctx.shadowColor = brick.glow;
                    ctx.shadowBlur = 10;
                    
                    ctx.fillStyle = brick.color;
                    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
                    
                    ctx.strokeStyle = brick.color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
                    ctx.restore();
                }
            });
        }

        // Update functions
        function updatePaddle() {
            paddle.x += paddle.dx;
            
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
            }

            // Si la bola no se ha lanzado, mantenerla en la paleta
            if (!ball.launched) {
                ball.x = paddle.x + paddle.width / 2;
                ball.y = paddle.y - ball.radius;
            }
        }

        function updateBall() {
            if (!ball.launched) return;

            ball.x += ball.dx;
            ball.y += ball.dy;

            // Colisi√≥n con paredes
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                ball.dx = -ball.dx;
                createParticles(ball.x, ball.y, '#22d3ee');
            }

            // Colisi√≥n con techo
            if (ball.y - ball.radius < 0) {
                ball.dy = -ball.dy;
                createParticles(ball.x, ball.y, '#22d3ee');
            }

            // Colisi√≥n con paleta
            if (ball.y + ball.radius > paddle.y && 
                ball.x > paddle.x && 
                ball.x < paddle.x + paddle.width &&
                ball.dy > 0) {
                
                const hitPos = (ball.x - paddle.x) / paddle.width;
                const angle = (hitPos - 0.5) * Math.PI / 2.5;
                const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                ball.dx = speed * Math.sin(angle);
                ball.dy = -speed * Math.cos(angle);
                
                createParticles(ball.x, ball.y, '#f472b6');
            }

            // Colisi√≥n con bloques
            bricks.forEach(brick => {
                if (brick.active) {
                    if (ball.x + ball.radius > brick.x &&
                        ball.x - ball.radius < brick.x + brick.width &&
                        ball.y + ball.radius > brick.y &&
                        ball.y - ball.radius < brick.y + brick.height) {
                        
                        ball.dy = -ball.dy;
                        brick.active = false;
                        score += brick.points;
                        
                        createParticles(brick.x + brick.width / 2, brick.y + brick.height / 2, brick.color);
                        
                        updateScore();
                        
                        // Check si complet√≥ el nivel
                        if (bricks.every(b => !b.active)) {
                            levelComplete();
                        }
                    }
                }
            });

            // Bola cae
            if (ball.y - ball.radius > canvas.height) {
                lives--;
                updateLives();
                
                if (lives <= 0) {
                    gameOver();
                } else {
                    resetBall();
                }
            }
        }

        function resetBall() {
            ball.x = paddle.x + paddle.width / 2;
            ball.y = paddle.y - ball.radius;
            ball.dx = 0;
            ball.dy = 0;
            ball.launched = false;
        }

        function updateScore() {
            document.getElementById('scoreHUD').textContent = `Score: ${score}`;
        }

        function updateLives() {
            document.getElementById('livesHUD').textContent = `‚ù§Ô∏è x ${lives}`;
        }

        function updateLevel() {
            document.getElementById('levelHUD').textContent = `Level ${level}`;
        }

        function levelComplete() {
            gameState = 'levelcomplete';
            document.getElementById('levelScore').textContent = `Score: ${score}`;
            document.getElementById('levelCompleteScreen').classList.remove('hidden');
        }

        function gameOver() {
            gameState = 'gameover';
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('brickBreakerHighScore', highScore);
            }
            
            document.getElementById('finalScore').textContent = `Score: ${score}`;
            document.getElementById('highScoreDisplay').textContent = `High Score: ${highScore}`;
            document.getElementById('gameOverScreen').classList.remove('hidden');
        }

        function startGame() {
            gameState = 'playing';
            document.getElementById('startScreen').classList.add('hidden');
            createBricks();
            resetBall();
        }

        function resetGame() {
            gameState = 'playing';
            score = 0;
            lives = 3;
            level = 1;
            
            updateScore();
            updateLives();
            updateLevel();
            
            paddle.x = canvas.width / 2 - 60;
            createBricks();
            resetBall();
            
            document.getElementById('gameOverScreen').classList.add('hidden');
        }

        function nextLevel() {
            level++;
            ball.speed += 0.5;
            
            updateLevel();
            createBricks();
            resetBall();
            
            gameState = 'playing';
            document.getElementById('levelCompleteScreen').classList.add('hidden');
        }

        // Game loop
        function gameLoop() {
            pollGamepad();
            
            if (gameState === 'playing') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                updatePaddle();
                updateBall();
                updateParticles();
                
                drawBricks();
                drawPaddle();
                drawBall();
                drawParticles();
            }
            
            requestAnimationFrame(gameLoop);
        }

        // Event listeners
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', resetGame);
        document.getElementById('nextLevelBtn').addEventListener('click', nextLevel);

        // Start game loop
        gameLoop();
    </script>
</body>
</html>